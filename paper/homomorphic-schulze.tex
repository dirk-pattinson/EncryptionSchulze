\documentclass{llncs}
\usepackage{amsmath,amsfonts,wrapfig,graphicx,caption,url}
\usepackage{subcaption}
\usepackage[all]{xy}
\captionsetup{compatibility=false}
\pagestyle{plain}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\st}{\mathsf{st}}
\newcommand{\LFP}{\mathsf{LFP}}
\newcommand{\Pow}{\mathsf{Pow}}
\newcommand{\GFP}{\mathsf{GFP}}

\begin{document}

\title{Verifiable Homomorphic Tallying for the Schulze Vote Counting
Scheme}

\author{Thomas Haines \inst{1} \and
      Dirk Pattinson\inst{2} \and Mukesh Tiwari \inst{2}}
\institute{Polyas, Denmark \and
          Research School of Computer Science, ANU, Canberra}
\maketitle

\begin{abstract}
The encryption of ballots is crucial to maintain integrity and 
anonymity of electronic voting schemes. It enables, amongst other 
things, each voter to verify that their encrypted ballot has been 
recorded as cast, by checking their ballot against a bulletin board. 

We present a verifiable homomorphic tallying scheme for the Schulze 
method that allows to verify the correctness of the count on the 
basis of encrypted ballots that only reveals the final tally. We 
achieve verifiability by using zero knowledge proofs for ballot 
validity and honest decryption of the final tally. Or formalisation 
takes places inside the Coq theorem prover and is based on an 
axiomatisation of cryptogtaphic primitives, and our main result is 
the correctness of homomorphic tallying. We then instantiate 
these primitives using an external library and show the feasibility 
of our approach by means of case studies.
\end{abstract}


\section{Introduction}
\begin{itemize}
  \item general need for crypt in vote counting
  \item gernal need for verifiablility in vote counting
  \item Description of the Schulze Method 
  \item related work
\end{itemize}

\section{Homomorphic Tallying}
\begin{itemize}
  \item general protocol, comparision with plaintext counting
  \item two-phase structure: margin matrix, then winners with
  winners as before: encryption commutes with margin computation
  \item homomorphic computation of margin matrix, ballot
  representation
  \item computation of winners (as for plaintext)
\end{itemize}

\section{Realisation in a Theorem Prover}
\begin{itemize}
  \item Axiomatisation of the cryptographic primitives
  \item correctness proof modulo correct crypto
  \item describe certificates and how to check them
  \item show that ``certificates certify''
\end{itemize}

\section{Extraction and Experiments}
\begin{itemize}
  \item coupling between library and extracted code
  \item need for light weight wrappers
  \item experimental results: how long, how much memory, certicicate
  size
\end{itemize}

\section{Analysis}
\begin{itemize}
  \item trust base: library, wrapper, bindings
  \item security: probabilistic aspects ignored, attacker model
  \item applicability to real world scenarios
\end{itemize}

\bibliography{all2,delta2}

\appendix
\section*{Notes and Leftovers Start Here}



\section{Format of Ballots}

%\begin{itemize}
%  \item motivate the choice of ballots and compare with plaintext
%  version
%  \item define encryption function that changes representation
%  \item a ballot is valid if and only if there is evidence that
%  proves its validity
%  \item encrypting valid ballots leads to valid ballots, and the
%  same for invalid ballots 
%  \item 
  Each ballot, B, is a $n\times$n matrix where n is the number of candidates 
  participating in
  election. Each voter marks the entry (i,j) in ballot B as 1 if he prefers 
  candidate i over j
  otherwise mark it 0. No candidate is preferred over itself, so all the 
  diagonal entries are 
  filled with 0. 
  The reason for representing a ballot as a matrix because the precise 
\begin{itemize}
  \item motivate the choice of ballots and compare with plaintext
  version
  \item define encryption function that changes representation
  \item a ballot is valid if and only if there is evidence that
  proves its validity
  \item encrypting valid ballots leads to valid ballots, and the
  same for invalid ballots 
  
  \item Each ballot, B, is a $n\times$n matrix where n is the number of 
  candidates participating in election. Each voter marks the entry (i, j) as 1 
  and (j, i) as -1 in ballot B if  he prefers candidate $i$ over $j$. If the voter 
  has no preference between candidate $i$ and $j $ i.e. they are ranked 
  same then voter would mark entry (i, j) and (j, i) as 0. No candidate is 
  preferred over itself, so all the diagonal entries are  filled with 0.  The
   reason for representing a ballot as a matrix because the precise 

  nature of our algorithm involving no decryption of individual ballot to protect
  ballot privacy,  facilitating the scrutiny for validity, and ease of computing 
  cumulative margin over encrypted data to compute the winners. 
  
  
   

  Each entry in ballot is encrypted by additive ElGamal i.e. encrypting the 
  message m as ($g^{r}, h^{r}g^{m}$) where $g$ is generator of cycle group $G$, and 
  $h = g^{x}$ is private key. After performing the encryption, a plain text ballot 
  i.e. matrix having entries of 0, and 1 changes to a matrix having pair for 

  \item  Each entry in ballot is encrypted by additive ElGamal i.e. encrypting the 
  message m as ($g^{r}, h^{r}g^{m}$) where $g$ is generator of cycle group $G$ of order $q$,  private key $x$ and randomness $r$  are randomly  
  chosen from \{1, \ldots, $q$ - 1\}, and public key is computed as 
  $h = g^{x}$. It is important to note that generator $g$, private key $x$ and 
  public key $h$ are generated during key generation phase of Elgamal 
  algorithm while  randomness $r$  is generated fresh for each message.
 \end{itemize} 
  After performing the encryption, a plain text ballot 
  i.e. matrix having entries of -1,  0, and 1 changes to a matrix having pair for 
  each entry representing the encryption of corresponding plain text. 
  A representation of plain text ballot  
  \[  
  \begin{bmatrix}
    x_{11}       & x_{12} & x_{13} & \dots & x_{1n} \\
    x_{21}       & x_{22} & x_{23} & \dots & x_{2n} \\
    \hdotsfor{5} \\
    x_{n1}       & x_{n2} & x_{n3} & \dots & x_{nn}
  \end{bmatrix}\] and data structure used to represent this ballot in 
  Coq is
  \begin{verbatim}
   Definition plaintext := Z.
   Definition pballot := cand -> cand -> plaintext.
  \end{verbatim}
  A representation of encrypted ballot 
  \[  
  \begin{bmatrix}
    (y_{11}, z_{11}) & (y_{12}, z_{12}) & (y_{13}, z_{13}) & \dots & (y_{1n}, z_{1n}) \\
    (y_{21}, z_{21}) & (y_{22}, z_{22}) & (y_{23}, z_{23}) & \dots & (y_{2n}, z_{2n}) \\
    \hdotsfor{5} \\
    (y_{n1}, z_{n1}) & (y_{n2}, z_{n2}) & (y_{n3}, z_{n3}) & \dots & (y_{nn}, z_{nn})
  \end{bmatrix}\] and the corresponding data structure in Coq is 
  \begin{verbatim}
   Definition ciphertext := (Z * Z)%type.
   Definition eballot := cand -> cand -> ciphertext.
  \end{verbatim}
     
 The reason for using additive ElGamal is that it's composability on ciphertext 
 under same public key. In short,  (Should I explain the algorithm here that 
  why this scheme works or explain it encryption section ?)
 \begin{center}  
	$enc_{k}(m_{1}) * enc_{k}(m_{2}) = enc_{k} (m_{1} + m_{2})$
 \end{center}
 Our choice of representing ballot as matrix comes with price. A malicious 
 voter could try to encode all sort of ballots including cyclic ones i.e. candidate
 $A$ is preferred over candidate $B$, candidate $B$ is preferred over candidate $C$, 
 and candidate $C$ is preferred over candidate $A$, and it is clear that voter has
 not expressed his choices clearly as it can not be expressed in linear preference order 
 and should not be considered for counting, or 
 he could inflate his favourite candidate by any other number higher that 1, and It 
 makes the ballot invalid because any value greater that 1 in a ballot would be similar
 to voter has casted more than one vote. We define a ballot is valid if all the 
 entries in matrix is encryption of -1, 0 and 1, and there is no cycle in it. Formally, We have
 \begin{verbatim}
 
	Definition matrix_ballot_valid (p : pballot) :=
      (forall c d : cand, In (p c d) [-1; 0; 1]) /\
	       valid cand p.  
 
 
 Definition valid (A : Type) (P : A -> A -> Z) :=
      exists f : A -> nat,
          forall c d : A,
          (P c d = 1 <-> (f c < f d)%nat) /\
          (P c d = 0 <-> f c = f d) /\ 
          (P c d = -1 <-> (f c > f d)%nat)
          
     (* Which one should keep ? Upper one is in Code while this one is 
        more intutive after expanding the definition *) 
    Definition matrix_ballot_valid (p : pballot) :=
      (forall c d : cand, In (p c d) [-1; 0; 1]) /\
      (exists f : A -> nat,
          forall c d : A,
          (p c d = 1 <-> (f c < f d)%nat) /\
          (p c d = 0 <-> f c = f d) /\ 
          (p c d = -1 <-> (f c > f d)%nat))
    
 \end{verbatim}
 Intuitively, it says that a ballot p is valid if we can find a function which
  expresses 
 the notion of linear preference ordering for all candidates, and 
 we prove that we can decide for each ballot if it is valid or not 
 \begin{verbatim}
  Lemma matrix_ballot_valid_dec : 
        forall p : pballot, {matrix_ballot_valid p} +
                            {~matrix_ballot_valid p}.
 \end{verbatim}
 
 By now, a attentive reader would note that we have claimed that we don't decrypt
 the ballot to preserve the privacy, so how can we decide the validity 
 without decrypting the original ballot. We will discuss our whole cryptographic 
 scheme in next section, but to quench the thrust of reader for now, we have 
 proved that if ballot p was valid
 before encryption, then encrypting it followed by permuting each row by 
 secret permutation $\sigma$ and permuting again the each column of resulting matrix 
 from  previous step by same permutation, $\sigma$, and decrypting it back would
 still 
 lead to valid ballot. 
 (* Write this same Lemma for $matrix_ballot_valid$ then 
      any permutation of it is valid and if it is invalid then any permutation of 
       it is invalid. The proof is already lying there in other proofs so 
       it's basically copy paste.   *)
 \begin{verbatim}
 Lemma perm_presv_validity :
     forall (A : Type) (P : A -> A -> Z),
       (forall c d : A, {c = d} + {c <> d}) ->
       (forall c d : A, {P c d = 1} + {P c d = 0} + {P c d = -1}) ->
       forall sig : A -> A, Bijective sig -> valid A P <-> valid A (perm A P sig)
 \end{verbatim}
 And similarly, for invalid ballot 
 \begin{verbatim}
 Lemma not_perm_persv_validity :
  forall (A : Type) (P : A -> A -> Z),
       (forall c d : A, {c = d} + {c <> d}) ->
       (forall c d : A, {P c d = 1} + {P c d = 0} + {P c d = -1}) ->
       forall sig : A -> A, Bijective sig -> ~ valid A P <-> ~ valid A (perm A P sig).
\end{verbatim}
%\end{itemize}

\section{Homomorphic Computation of Margin}
\begin{itemize}
  \item motivate and introduce how the margin is computed
  homomorphcially
  \item prove that encrption commutes with computation of margin
  
\end{itemize}

\section{Homomorphic Counting}
\begin{itemize}
  \item prove that encruption commutes with computation of winners
  \item discuss the evidence: publish cleartext margin function
  \item describe certificates and how to check them
\end{itemize}

\section{Experimental Results}
\begin{itemize}
  \item how long does it take, and how much memory?
  \item how large are the certificates?
\end{itemize}


\section{Discussion and Further Work}



One aspect that we have not considered here is encryption of
ballots to safe-guard voter privacy which can be incorporated using
protocols such as shuffle-sum \cite{Benaloh:2009:SSC} and
homomorphic encryption \cite{Yi:2014:HEA}. The key idea here is to
formalise a given voting scheme based on encrypted ballots, and then
to establish a homomorphic property: the decryption of the result
obtained from encrypted ballots is the same as the result obtained from
the decrypted ballots.  We leave this to further work.

\bibliographystyle{myplain}
\bibliography{all2,delta2}


\end{document}
