\documentclass{llncs}
\usepackage{amsmath,amsfonts,wrapfig,graphicx,caption,url}
\usepackage{subcaption}
\usepackage[all]{xy}
\captionsetup{compatibility=false}
\pagestyle{plain}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\st}{\mathsf{st}}
\newcommand{\LFP}{\mathsf{LFP}}
\newcommand{\Pow}{\mathsf{Pow}}
\newcommand{\GFP}{\mathsf{GFP}}

\begin{document}

\title{No More Excuses: Automated Synthesis of Practical and
Verifiable Vote-counting Programs for Complex Voting Schemes}

\author{Thomas Haines \inst{1} \and
      Dirk Pattinson\inst{2} \and Mukesh Tiwari \inst{2}}
\institute{Polyas, Denmark \and
          Research School of Computer Science, ANU, Canberra}
\maketitle

\begin{abstract}


\end{abstract}


\section{Introduction}
(leave this until the very end)

\section{The Schulze Method}
(this should be similar to other papers that we already have)

\section{Format of Ballots}

\begin{itemize}
  \item motivate the choice of ballots and compare with plaintext
  version
  \item define encryption function that changes representation
  \item a ballot is valid if and only if there is evidence that
  proves its validity
  \item encrypting valid ballots leads to valid ballots, and the
  same for invalid ballots 
  
  Each ballot, B, is a $n\times$n matrix where n is the number of candidates 
  participating in
  election. Each voter marks the entry (i,j) in ballot B as 1 if he prefers 
  candidate i over j
  otherwise mark it 0. No candidate is preferred over itself, so all the 
  diagonal entries are 
  filled with 0. 
  The reason for representing a ballot as a matrix because the precise 
  nature of our algorithm involving no decryption of individual ballot to protect
  ballot privacy, 
  Schulze's method involving the computation of margin 
  (I am assuming here that margin would 
  already be clear because of previous section) to compute the winners, and ease of 
  doing computation over encrypted data than linear representation of ballot. 
  Each entry in ballot is encrypted by additive ElGamal 
  
   
\end{itemize}

\section{Homomorphic Computation of Margin}
\begin{itemize}
  \item motivate and introduce how the margin is computed
  homomorphcially
  \item prove that encrption commutes with computation of margin
\end{itemize}

\section{Homomorphic Counting}
\begin{itemize}
  \item prove that encruption commutes with computation of winners
  \item discuss the evidence: publish cleartext margin function
  \item describe certificates and how to check them
\end{itemize}

\section{Experimental Results}
\begin{itemize}
  \item how long does it take, and how much memory?
  \item how large are the certificates?
\end{itemize}


\section{Discussion and Further Work}



One aspect that we have not considered here is encryption of
ballots to safe-guard voter privacy which can be incorporated using
protocols such as shuffle-sum \cite{Benaloh:2009:SSC} and
homomorphic encryption \cite{Yi:2014:HEA}. The key idea here is to
formalise a given voting scheme based on encrypted ballots, and then
to establish a homomorphic property: the decryption of the result
obtained from encrypted ballots is the same as the result obtained from
the decrypted ballots.  We leave this to further work.

\bibliographystyle{myplain}
\bibliography{all2,delta2}


\end{document}
