\documentclass{llncs}
\usepackage{amsmath,amsfonts,wrapfig,graphicx,caption,url}
\usepackage{subcaption}
\usepackage[all]{xy}
\captionsetup{compatibility=false}
\pagestyle{plain}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\st}{\mathsf{st}}
\newcommand{\LFP}{\mathsf{LFP}}
\newcommand{\Pow}{\mathsf{Pow}}
\newcommand{\GFP}{\mathsf{GFP}}

\begin{document}

\title{No More Excuses: Automated Synthesis of Practical and
Verifiable Vote-counting Programs for Complex Voting Schemes}

\author{Thomas Haines \inst{1} \and
      Dirk Pattinson\inst{2} \and Mukesh Tiwari \inst{2}}
\institute{Polyas GmbH, Germany \and
          Research School of Computer Science, ANU, Canberra}
\maketitle

\begin{abstract}


\end{abstract}


\section{Introduction}
(leave this until the very end)

\section{The Schulze Method}
(this should be similar to other papers that we already have)

\section{Format of Ballots}

\begin{itemize}
  \item motivate the choice of ballots and compare with plaintext
  version
  \item define encryption function that changes representation
  \item a ballot is valid if and only if there is evidence that
  proves its validity
  \item encrypting valid ballots leads to valid ballots, and the
  same for invalid ballots 
  \item 
  Each ballot, B, is a $n\times$n matrix where n is the number of candidates 
  participating in
  election. Each voter marks the entry (i,j) in ballot B as 1 if he prefers 
  candidate i over j
  otherwise mark it 0. No candidate is preferred over itself, so all the 
  diagonal entries are 
  filled with 0. 
  The reason for representing a ballot as a matrix because the precise 
  nature of our algorithm involving no decryption of individual ballot to protect
  ballot privacy, 
  Schulze's method involving the computation of margin 
  (I am assuming here that margin would 
  already be clear because of previous section) to compute the winners, and ease of 
  doing computation over encrypted data than linear representation of ballot.
   
  \item  Each entry in ballot is encrypted by additive ElGamal i.e. encrypting the 
  message m as ($g^{r}, h^{r}g^{m}$) where $g$ is generator of cycle group $G$, and 
  $h = g^{x}$ is private key. After performing the encryption, a plain text ballot 
  i.e. matrix having entries of 0, and 1 changes to a matrix having pair for 
  each entry representing the encryption of corresponding plain text. 
  A representation of plain text ballot 
  \[  
  \begin{bmatrix}
    x_{11}       & x_{12} & x_{13} & \dots & x_{1n} \\
    x_{21}       & x_{22} & x_{23} & \dots & x_{2n} \\
    \hdotsfor{5} \\
    x_{n1}       & x_{n2} & x_{n3} & \dots & x_{nn}
  \end{bmatrix}\]
  A representation of encrypted ballot 
  \[  
  \begin{bmatrix}
    (y_{11}, z_{11}) & (y_{12}, z_{12}) & (y_{13}, z_{13}) & \dots & (y_{1n}, z_{1n}) \\
    (y_{21}, z_{21}) & (y_{22}, z_{22}) & (y_{23}, z_{23}) & \dots & (y_{2n}, z_{2n}) \\
    \hdotsfor{5} \\
    (y_{n1}, z_{n1}) & (y_{n2}, z_{n2}) & (y_{n3}, z_{n3}) & \dots & (y_{nn}, z_{nn})
  \end{bmatrix}\]
     
 The reason for using additive ElGamal is that it's composability on ciphertext 
 under same public key ( Try to rephrase it or move it to Homomorphic section!). 
 In short, 
 \begin{center}  
	$enc_{k}(m_{1}) * enc_{k}(m_{2}) = enc_{k} (m_{1} + m_{2})$
 \end{center}
 \item Our choice of representing ballot as matrix comes with price. A malicious 
 voter could try to encode all sort of ballots including cyclic ones i.e. candidate
 $A$ is preferred over candidate $B$, candidate $B$ is preferred over candidate $C$, 
 and candidate $C$ is preferred over candidate $A$, and it is clear that voter has
 not expressed his choices clearly as it can not be expressed in linear preference order 
 and should not be considered for counting, or 
 he could inflate his favourite candidate by any other number higher that 1, and It 
 makes the ballot invalid because any value greater that 1 in a ballot would be similar
 to voter has casted more than one vote. We define a ballot is valid if all the 
 entries in matrix is encryption of 0 and 1, and there is no cycle in it. Formally, We
 have
 \begin{verbatim}
  Definition valid (A : Type) (P : A -> A -> Prop) := 
  	exists (f : A -> nat), forall (c d : A), P c d <-> (f c < f 	d)%nat.
 \end{verbatim}
 and we instantiate this notion of validity for any ballot b by saying that 
 \begin{verbatim}
  Definition valid cand (fun c d => b c d = 1) := 
  	exists (f : cand -> nat), forall (c d : cand), b c d = 1 <-> (f c < f d)%nat.
 \end{verbatim}
 Intuitively, it says that a ballot b is valid if we can find a function which expresses 
 the notion of linear preference ordering for all candidates, and 
 we prove that we can decide for each ballot if it is valid or not 
 \begin{verbatim}
 Lemma pballot_valid_dec :
      forall b : ballot, {valid cand (fun c d => b c d = 1)} +
                         {~(valid cand (fun c d => b c d = 1))}.
 \end{verbatim}
 
 By now, a attentive reader would note that we have claimed that we don't decrypt
 the ballot to preserve the privacy, so how can we decide the validity 
 without decrypting the original ballot. We will discuss our whole cryptographic 
 scheme in next section, but to quench the thrust of reader for now, we have 
 proved that if ballot b was valid
 before encryption, then encrypting it followed by permuting each row by 
 secret permutation $\sigma$ and permuting again the each column of resulting matrix 
 from  previous step by same permutation, $\sigma$, and decrypting it back would
 still 
 lead to valid ballot. (Is it giving too much information ? ) 
 \begin{verbatim}
 Lemma perm_presv_validity :
  forall (A : Type) (P : A -> A -> Prop)
         (Adec : forall (c d : A), {c = d} + {c <> d})
         (Pdec : forall c d, {P c d} + {~P c d}) 
         (sig : A -> A)
         (Hsig : Bijective sig), 
	valid A P <-> valid A (perm A P sig).	
 \end{verbatim}
 And similarly, for invalid ballot 
 \begin{verbatim}
 Lemma not_perm_persv_validity :
  forall (A : Type) (P : A -> A -> Prop)
         (Adec : forall (c d : A), {c = d} + {c <> d})
         (Pdec : forall c d, {P c d} + {~P c d}) 
         (sig : A -> A)
         (Hsig : Bijective sig),
	~valid A P <-> ~valid A (perm A P sig).
\end{verbatim}
\end{itemize}

\section{Homomorphic Computation of Margin}
\begin{itemize}
  \item motivate and introduce how the margin is computed
  homomorphcially
  \item prove that encrption commutes with computation of margin
\end{itemize}

\section{Homomorphic Counting}
\begin{itemize}
  \item prove that encruption commutes with computation of winners
  \item discuss the evidence: publish cleartext margin function
  \item describe certificates and how to check them
\end{itemize}

\section{Experimental Results}
\begin{itemize}
  \item how long does it take, and how much memory?
  \item how large are the certificates?
\end{itemize}


\section{Discussion and Further Work}



One aspect that we have not considered here is encryption of
ballots to safe-guard voter privacy which can be incorporated using
protocols such as shuffle-sum \cite{Benaloh:2009:SSC} and
homomorphic encryption \cite{Yi:2014:HEA}. The key idea here is to
formalise a given voting scheme based on encrypted ballots, and then
to establish a homomorphic property: the decryption of the result
obtained from encrypted ballots is the same as the result obtained from
the decrypted ballots.  We leave this to further work.

\bibliographystyle{myplain}
\bibliography{all2,delta2}


\end{document}
