\documentclass{llncs}
\usepackage{amsmath,amsfonts,wrapfig,graphicx,caption,url}
\usepackage{subcaption}
\usepackage[all]{xy}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\captionsetup{compatibility=false}
\pagestyle{plain}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\st}{\mathsf{st}}
\newcommand{\str}{\mathsf{str}}
\newcommand{\encb}{\mathrm{eb}}
\newcommand{\EncB}{\mathrm{EM}}
\newcommand{\encm}{\mathrm{em}}
\newcommand{\CT}{\mathbb{CT}}
\newcommand{\dec}{\mathsf{dec}}
\newcommand{\enc}{\mathsf{enc}}

\begin{document}

\title{Verifiable Homomorphic Tallying for the Schulze Vote Counting
Scheme}

\author{Thomas Haines \inst{1} \and
      Dirk Pattinson\inst{2} \and Mukesh Tiwari \inst{2}}
\institute{Polyas GmbH, Germany \and
          Research School of Computer Science, ANU, Canberra}
\maketitle

\begin{abstract}
The encryption of ballots is crucial to maintaining integrity and 
anonymity in electronic voting schemes. It enables, amongst other 
things, each voter to verify that their encrypted ballot has been 
recorded as cast, by checking their ballot against a bulletin board. 

We present a verifiable homomorphic tallying scheme for the Schulze 
method that allows verification of the correctness of the count on the 
basis of encrypted ballots that only reveals the final tally. We 
achieve verifiability by using zero knowledge proofs for ballot 
validity and honest decryption of the final tally. Our formalisation 
takes places inside the Coq theorem prover and is based on an 
axiomatisation of cryptogtaphic primitives, and our main result is 
the correctness of homomorphic tallying. We then instantiate 
these primitives using an external library and show the feasibility 
of our approach by means of case studies.
\end{abstract}


\section{Introduction}

Secure elections are a balancing act between integrity and privacy:
achieving either is trivial but their combination is notoriously hard.
One of the key challenges faced by both paper based and electronic
elections is that results must substantiated with
verifiable evidence of their correctness while retaining the secrecy
of the individual ballot \cite{Bernhard:2017:PES}.  Technically, the
notion of ``verifiable evidence'' is captured by the term 
\emph{end-to-end (E2E) verifiability}, that is
\begin{itemize}
  \item every voter can verify that their ballot was cast as
  intended
  \item every voter can verify that their ballot was collected as
  cast
  \item everyone can verify final result on the basis of the
  collected ballots.
\end{itemize}
While end-to-end verifiability addresses the basic assumption that
no entity (software, hardware and participants) are inherently
trustworthy, ballot secrecy addresses the privacy problem.
Unfortunately, it appears as if coercion resistance is not achievable  
in the remote setting without relying on overly optimistic---to say the least---assumptions.
A weaker property called receipt-freeness captures the idea that an honest 
voter---while able to verify that their ballot was counted---is required to keep 
no information that a possible coercer could use to verifying how that voter had voted.

End to end verifiability and the related notation of software independence~\cite{Rivest:2008:PTRS}
 have been claimed properties for many voting schemes.  Kusters et al~\cite{Kusters:2010:CCS} gave
 a cryptographic formulation whose value is highlighted by the attacks it revealed in established voting 
 schemes~\cite{Kusters:2012:SP}.

The combination of privacy and integrity can be realised using cryptographic techniques, where
encrypted ballots (that the voters themselves cannot decrypt) are
published on a bulletin board, and the votes are then processed, and
the correctness of the final tally is substantiated, using
homomorphic encryption \cite{Hirt:2000:ERF} and verifiable shuffling
\cite{Bayer:2012:EZK}. (Separate techniques exist to prevent ballot
box stuffing and to guarantee cast-as-intended.)
Integrity can then be guaranteed by means of Zero Knowledge Proofs
(ZKP),
first studied by Goldwasser, Micali, and Rackoff~\cite{Goldwasser:1985:STOC}.
Informally, a ZKP is a probabilistic and interactive proof where one
entity provides evidence about knowledge of a secret without
providing no information other than the truth of the statement, with
overwhelming probability. 
Later results~\cite{Goldreich:1991:ACM}\cite{Ben-Or:1988:CRYPTO} showed that 
all problems for which solutions can be efficiently verified have zero knowledge
proofs.


This paper addresses the problem of verifiable homomorphic tallying
for a preferential voting scheme, the Schulze voting scheme. We show
how the Schulze Method can be implemented in a theorem prover to
guarantee both provably correct and verifiable counting on the basis
of encrypted ballots, relative to an axiomatisation of the
cryptographic primitives. We then obtain, via program extraction, a
provably correct implementation of the vote counting, that we turn
into executable code by providing implementations of the primitives
based on a standard cryptographic library. We conclude by presenting
experimental results, and discuss trust the trust base, security and
privacy as well as the applicability of our work to real-world
scenarios. 

\subsection*{Leftover Text?}
In general, every election has purpose to elect candidates based on cast
  ballots while maintaining the integrity of election i.e. tallied correctly, 
  maintained individual ballot privacy, and coercions free. Many of these properties 
  we get for free in paper ballot election, but for electronic voting, not only 
  our protocol should have these properties, but at the same time they should be 
  evident. The inherent nature of tension (conflict) between privacy, keeping the votes 
  private and anonymous (unidentifiable), and universal verifiablity, anyone can verify
  tallying is correct (consistent) according to election rules, makes electronic 
  voting schemes very challenging. If we publish 
  the ballots in plain text it certainly offers universal verifiability, but at the same
  time it opens the possibility of coercion \cite{Benaloh:2009:SSC}, and if we don't
  publish then it certainly offers the more privacy, but hampers universal 
  verifiablity. \linebreak
      
  \smallskip\noindent\emph{The Schulze Method.} The Schulze Method
  \cite{Schulze:2011:NMC} is a preferential, single-winner vote
  counting scheme that is gaining popularity due to its relative
  simplicity while retaining near optimal fairness
  \cite{Rivest:2010:OSW}.  
  A \emph{ballot} is a rank-ordered list of
  candidates where different candidates may be given the same rank.
  The protocol proceeds in two steps, and first computes the
  \emph{margin matrix} $m$ where, for candidates $x$ and $y$, 
  \[ m(x, y) = \mbox{ballots that rank $x$ higher than $y$} - \mbox{ballots
  that rank $y$ higher than $x$}. \]
  We note that $m(x, y) = -m(y, x)$, i.e. the margin matrix is
  symmetric. In a second step, a \emph{generalised margin} $g$ is
  computed as the strongest path between two candidates
  \[ g(x,y) = \max \lbrace \str(p) \mid p \mbox{ path from $x$ to
  $y$} \rbrace \]
  where a path from $x$ to $y$ is simply a sequence $x = x_0, \dots,
  x_n = y$ of candidates, and the strength
  \[ \str(x_0, \dots, x_n) = \min \lbrace m(x_i, x_{i+1}) \mid i < n
  \rbrace  \]
  is the lowest margin encountered on a path.

  A candidate $w$ is a \emph{winner} if $g(w, x) \geq g(x, w)$ for
  all other candidates $x$. Informally, one may think of the
  generalised margin $g(x, y)$ as transitive accumulated support for
  $x$ over $y$, so that $x$ beats $y$ if $g(x,y) \geq g(y, x)$ and a
  winner is a candidate that cannot be beaten by anyone. Note that
  winners may not be uniquely determined (e.g. in the case where no
  ballots have been cast).

  In previous work \cite{Pattinson:2017:SVE} we have demonstrated
  how to achieve verifiability of counting plaintext ballots by
  producing a verifiable \emph{certificate} of the count. The
  certificate has two parts: The first part witnesses the
  computation of the margin function where each line of the
  certificate amounts to updating the margin function by a single
  ballot. The second part witnesses the determination of winners
  based on the margin function. In the first phase, i.e. the
  computation of the margin function, we perform the following
  operations for every ballot:
  \begin{enumerate}
    \item if the ballot is informal it will be discarded
    \item if the ballot is formal, the margin function will be
    updated
  \end{enumerate}
  The certificate then contains one line for each ballot and thus
  allows to independently verify the computation of the margin
  function. Based on the final margin function, the second part of
  the certificate presents verifiable evidence for the computation
  of winners. Specifically, if a candidate $w$ is a winner, it
  includes:
  \begin{enumerate}
    \item an integer $k$ and a path of strength $k$ from $w$ to any
    other candidate
    \item evidence, in the form of a co-closed set, of the fact that
    there cannot be a path of strength $> k$ from any other
    candidate to $w$.
  \end{enumerate}
  Crucially, the evidence of $w$ winning the election \emph{only}
  depends on the margin matrix. 
  We refer to \cite{Pattinson:2017:SVE} for details of the second
  part of the certificate as this will remain unchanged in the work
  we are reporting here.
    
\noindent\smallskip\emph{Related Work.} The paper that is closest to
our work is an algorithm for homomorphic counting for Single
Transferable Vote \cite{Benaloh:2009:SSC}. While single transferable
vote is arguably more complex that the Schulze Method, we have
demonstrated the viability of our approach by implementing it in a
theorem prover, and have extracted, and evaluated, an executable
based on the formal proof development. The idea of formalising
evidence for winning elections has been put forward (for plaintext
ballots) in \cite{Pattinson:2015:VCM}. 

\section{Verifiable Homomorphic Tallying}
\texttt{
  Bullet points of content for reference and later deletion
\begin{itemize}
  \item general protocol, comparision with plaintext counting
  \item two-phase structure: margin matrix, then winners with
  winners as before: encryption commutes with margin computation
  \item homomorphic computation of margin matrix, ballot
  representation
  \item computation of winners (as for plaintext)
\end{itemize}
}
The realisation of verifiable of homomorphic tallying that we are about to
describe follows the same two phases as the protocol: for each
ballot, we decide whether it is formal, and if so, homomorphically
update the margin function. We do this for every ballot, and record
this in the certificate. We then record the decryption of the margin
function in the certificate, and then publish the winner, together
with evidence based on the margin matrix, as in the case of counting
plaintext ballots (where evidence for winning also only depends on
the margin matrix).  We now describe the two phases in detail.

\smallskip\noindent\emph{Format of Ballots.} In preferential voting
schemes, ballots are rank-ordered lists of candidates. For the
Schulze Method, we require that all candidates are ranked, and two
candidates may be given the same rank. That is, a ballot is most
naturally represented as a function $b: C \to \Nat$ that assigns a
numerical rank to each candidate, and the computation of the margin
amounts to computing the sum
\[ m(x, y) = \sum_{b \in B} \begin{cases} +1 & b(x) > b(y) \\ 0 &
b(x) = b(y) \\ -1 & b(x) < b(y) \end{cases} \]
where $B$ is the multi-set of ballots, and each $b \in B$ is a
ranking function $b: C \to \Nat$ over a (finite) set $C$ of
candidates. 

We note that this representation of ballots is not well suited for
homomorphic computation of the margin matrix as practically feasible
homomorphic encryption schemes do not support comparison operators
and case distinctions as used in the formula above. 

We instead represent ballots as matrices
$b(x, y)$ where $b(x, y) = +1$ if $x$ is preferred
over $y$, $b(x, y) = -1$ if $y$ is preferred over $x$ and $b(x, y) =
0$ if $x$ and $y$ are equally preferred.

While the advantage of the first representation is that each ranking
function is necessarily a valid ranking, the advantage of the matrix 
representation is that the computation of
the margin matrix is simple, that is
\[ m(c, d) = \sum_{b \in B} b(x, y) \]
where $B$ is the multi-set of ballots (in matrix form), and can
moreover be transferred to the encrypted setting in a straight
forward way: if ballots are matrices $e(x,y)$ where $e(x,y)$ is the
encryption of an integer, then
\[ \encm = \bigoplus_{\encb \in \EncB} \encb(x, y) \]
where $\oplus$ denotes homomorphic addition, $\encb$ is an encrypted
ballot in matrix form (i.e. decrypting $\encb(x, y)$ indicates
whether $x$ is preferred over $y$), and $\EncB$ is the multi-set of
encrypted ballots. The disadvantage is that we need to verify that a
matrix ballot is indeed valid, that is
\begin{itemize}
\item that the decryption of $\encb(x, y)$ is indeed one of $1, 0$ or
$-1$
\item that $\encb$ indeed corresponds to a ranking function.
\end{itemize}

Indeed, to achieve verifiability, we not only need \emph{verify}
that a ballot is valid, we also need to \emph{evidence} its validity
(or otherwise) in the certificate.  

\smallskip\noindent\emph{Validity of Ballots.} By a plaintext
(matrix) ballot
we simply mean a function $b: C \times C \to \Z$,
where $C$ is the (finite) set of candidates. A 
plaintext ballot $b(x, y)$ 
is \emph{valid} if it is induced by a ranking function, i.e.
there exists a function $f: C \to \Nat$ such that $b(x, y) = 1$ if
$f(x) < f(y)$, $b(x, y) = 0$ if $f(x) = f(y)$ and $b(x, y) = -1$ if
$f(x) > f(y)$. A \emph{ciphertext (matrix) ballot} is a function
$\encb: C \times C \to \CT$ (where $\CT$ is a chosen set of
ciphertexts), and it is valid if the pointwise encryption, i.e. the
matrix ballot $b(x, y) = \dec(\enc(x,y))$ is valid (we use $\dec$ to
denote decryption). 

For a plaintext ballot, it is easy to decide whether it is
valid (and should be counted) or not (and should be discarded). We
use shuffles (ballot permutations) to evidence the validity of
encrypted ballots. One observes that a matrix ballot is valid if and
only if it is valid after permuting both rows and columns with the
same permutation. That is, $b(x,y)$ is valid if and only if $b'(x,y)$
is valid, where
\[ b'(x,y) = b(\pi(x), \pi(y)) \]
and $\pi: C \to C$ is a permutation of candidates. (Indeed, if $f$
is a ranking function for $b$, then $f \circ \pi$ is a ranking
function for $b'$). As a consequence, we can evidence the validity
of a ciphertext ballot $\encb$ by
\begin{itemize}
  \item publishing a shuffled version $\encb'$ of $\encb$, that is
  shuffled by a secret permutation, together with
  evidence that $\encb'$ is indeed a shuffle of $\encb$
  \item publishing the decryption $b'$ of $\encb'$ together with
  evidence that $b'$ is indeed the decryption of $\encb'$.
\end{itemize}

We use zero-knowledge proofs in the style of \cite{Bayer:2012:EZK}
to evidence the correctness of the shuffle, and zero-knowledge
proofs of honest decryption [reference missing] to evidence
correctness of decryption. This achieves ballot secrecy owing to the
fact that the permutation is never revealed.


In summary, the homomorphic computation of the margin matrix starts
with an encryption of the zero margin $\encm$, and for each
ciphertext ballot $\encb$
\begin{enumerate}
\item publishes a shuffle of $\encb$ together with a ZKP of 
correctness
\item publishes the decryption of a shuffle, together with a ZKP of
correctness
\item publishes the updated margin function, if the decrypted ballot
was valid, and
\item publishes the unchanged margin function, if the decrypted
ballot is not valid.
\end{enumerate}

\smallskip\noindent\emph{Witnessing of Winners.}
Once all ballots are counted, the computed margin is decrypted, and
winners (together with evidence of winning) are being computed as
for plaintext counting. We discuss this this part only briefly to be
self contained as it is as for plaintext counting
\cite{Pattinson:2017:SVE}. For each of the winners $w$ and each
candidate $c$ we publish
\begin{itemize}
\item a natural number $k(w, x)$
\item a path $w = x_0, \dots, x_n = x$ of strength $k$
\item a set $C(w, x)$ of pairs of candidates that is $k$-coclosed
and contains $(x, w)$
\end{itemize}
where a set $S$ is  $k$-coclosed if for all $(x,z) \in C$ we have
that $m(x, z) < k$ and either $m(x, y) < k$ or $(y,z) \in S$ for
all candidates $y$.  Informally, the first requirement ensures that
there is no direct path (of length one) between a pair $(x, z) \in
S$ ,and the second requirement ensures that for an element $(x, z)
\in S$, there cannot be a path that connects $x$ to an intermediate
node $y$ and then (transitively) to $z$ that is of strength $\geq
k$. 
We refer to \emph{op.cit.} for the (formal)
proofs of the fact that existence of co-closed sets witnesses the
winning conditions. 
  



\section{Realisation in a Theorem Prover}
\texttt{
  Bullet points of content for reference and later deletion
\begin{itemize}
  \item Axiomatisation of the cryptographic primitives
  \item correctness proof modulo correct crypto
  \item describe certificates and how to check them
  \item show that ``certificates certify''
\end{itemize}}


Now we explain the cryptographic primitives in realization of 
verifiable homomorphic tally. These primitives are treated as 
abstract entity inside theorem prover Coq, and it includes 
private key, public key, and functions for encryption, decryption,
generating permutation, generating commitment \cite{Pederson}, shuffling 
a list of ciphertext by a given permutation, generating zero 
knowledge proof, and verification of zero knowledge proof. Since these 
entities are abstract entity inside Coq, we have assumed axioms about 
them, hence axiomatisation of cryptographic primitives.


(* I can explain these primitives that what does encryption and decryption 
do, what does generate permutation do,  but how to connect them with 
   counting explained below ?. *) 

We describe homomorphic Schulze counting as dependent inductive data type,
\textbf{ECount}. ECount is parametrised by, group, a triplet which includes 
generator, prime, and public key and used 
for cryptographic purpose, list of cast ballots, and depends on another 
inductive data type \textbf{EState}. 
The purpose of EState to capture the intermediate states 
of counting i.e. constructing homomorphic margin function, or 
decryption of fully constructed homomorphic margin function, or 
determination of final result. 

\begin{verbatim}
Inductive EState : Type :=
    | epartial : (list eballot * list eballot) ->
                 (cand -> cand -> ciphertext) -> EState
    | edecrypt : (cand -> cand -> plaintext) -> EState
    | ewinners : (cand -> bool) -> EState.
\end{verbatim}

Intuitively, we can construct element of type EState using three constructors 
epartial, edecrypt, and ewinners. The interpretation is 
\begin{itemize}
 \item epartial takes a pair, list of uncounted ballots and invalid ballots seen 
       so far, and computed homomorphic margin so far
 \item edecrypt takes final decrypted margin after all the ballots are counted
 \item ewinners take a boolean function which returns true(false) for winners(losers)
\end{itemize}

The interpretation of ECount is that inhabitant of this type is correct 
execution of homomorphic counting method. Intuitively, the counting 
start with first constructor, \textbf{ecax}, with list of all 
uncounted ballots us, encrypted zero margin encm, decrypted zero margin 
decm, and zero knowledge proof zkpdec of that decm is indeed honest decryption
of encm with assertions that ensures that all the uncounted ballots are 
equal to list of cast ballot, every entry in decm is zero and 
zero knowledge proof of honest decryption verifies. 


In next step, depending on validity of ballot we are counting (refer to 
previous section about we decide the validity of ballot), we either update the 
margin function homomorphically, \textbf{ecvalid}, or move it to the 
list of invalid ballots, \textbf{ecinvalid}. Basically deciding 
the validity of ballot involves shuffle by permutation, which
we don't want to reveal to achieve ballot secrecy, and decryption, so 
we need to produce compelling evidence 
to make sure that the operation performed in each step of deciding validity 
is verifiable. 

To hide the permutation we use the well known protocol Pedersen's 
commitment \cite{Pederson}. Pedersen commitment scheme has 
the following properties. 
\begin{itemize}
\item Hiding: A dishonest party can't discover honest party's value 
\item Binding: A dishonest party cannot open his commitment in more  
	 	than one way i.e. he should not be able open to a value 
	 	different from the one he committed to 
\end{itemize}


We hide the permutation, \textbf{pi}, by committing it and publishing 
the commitment \textbf{cpi}, but rather than opening the permutation pi 
to show that it's the permutation that we committed to in later phase of 
protocol, we generate zero knowledge proof,
 \textbf{zkpcpi}, using permutation pi and its commitment cpi. This 
 zero knowledge proof can be  used to prove that cpi is indeed a commitment 
 of some permutation without revealing (opening) it. 
 
Now that we have permutation pi, we use it permute(shuffle) each row of 
ballot \textbf{u} producing \textbf{v} with zero knowledge evidence 
\textbf{zkppermuv}, and permuting each column 
of v to produce ballot \textbf{w} with zero knowledge evidence 
\textbf{zkppermvw}. We decrypt ballot w to produce ballot \textbf{b} 
which in turn used to decide the validity of original ballot u, and 
this step is again accompanied by zero knowledge evidence \textbf{zkpdecw}.


The constructor, \textbf{ecdecrypt}, marks the finish to counting with 
fully constructed encrypted margin \textbf{encm}, 
decrypted margin \textbf{decm} with honest decryption zero knowledge proof, 
\textbf{zkp}.

The final constructor, \textbf{ecfin}, takes fully decrypted margin 
\textbf{dm}, boolean function \textbf{w} that determines election winner, 
and \textbf{d}, that delivers type level evidence of winning or losing, 
consistent with w.


\begin{verbatim}
Inductive ECount (group : Group) (bs : list eballot) : EState -> Type :=
 | ecax (us : list eballot) (encm : cand -> cand -> ciphertext)
        (decm : cand -> cand -> plaintext)
        (zkpdec : cand -> cand -> DecZkp) :
        us = bs ->
        (forall c d : cand, decm c d = 0) -> 
        (forall c d, verify_zero_knowledge_decryption_proof 
                  grp (decm c d) (encm c d) (zkpdec c d) = true) ->
        ECount grp bs (epartial (us, []) encm)
 | ecvalid (cpi : Commitment) (zkpcpi : PermZkp)
           (u : eballot) (v : eballot) (w : eballot)
           (b : pballot) (zkppermuv : cand -> ShuffleZkp)
           (zkppermvw : cand -> ShuffleZkp) 
           (zkpdecw : cand -> cand -> DecZkp)
           (us : list eballot) (m nm : cand -> cand -> ciphertext)
           (inbs : list eballot) :
   ECount grp bs (epartial (u :: us, inbs) m) ->
   matrix_ballot_valid b ->
   (verify_permutation_commitment grp (length cand_all) cpi zkpcpi = true) ->
   (forall c, verify_row_permutation_ballot grp u v cpi zkppermuv c = true) ->
   (forall c, verify_col_permutation_ballot grp v w cpi zkppermvw c = true) ->
   (forall c d, verify_zero_knowledge_decryption_proof 
                  grp (b c d) (w c d) (zkpdecw c d) = true) ->
   (forall c d, nm c d = homomorphic_addition grp (u c d) (m c d)) -> 
   ECount grp bs (epartial (us, inbs) nm)
 | ecinvalid (cpi : Commitment) (zkpcpi : PermZkp)
             (u : eballot) (v : eballot) (w : eballot)
             (b : pballot) (zkppermuv : cand -> ShuffleZkp)
             (zkppermvw : cand -> ShuffleZkp) 
             (zkpdecw : cand -> cand -> DecZkp)
             (us : list eballot) (m : cand -> cand -> ciphertext)
             (inbs : list eballot) :
   ECount grp bs (epartial (u :: us, inbs) m) ->
   ~matrix_ballot_valid b ->
   (verify_permutation_commitment grp (length cand_all) cpi zkpcpi = true) ->
   (forall c, verify_row_permutation_ballot grp u v cpi zkppermuv c = true) ->
   (forall c, verify_col_permutation_ballot grp v w cpi zkppermvw c = true) ->
   (forall c d, verify_zero_knowledge_decryption_proof 
                  grp (b c d) (w c d) (zkpdecw c d) = true) ->
   ECount grp bs (epartial (us, (u :: inbs)) m)
 | ecdecrypt inbs (encm : cand -> cand -> ciphertext)
             (decm : cand -> cand -> plaintext)
             (zkp : cand -> cand -> DecZkp) :
   ECount grp bs (epartial ([], inbs) encm) ->
   (forall c d, verify_zero_knowledge_decryption_proof
                  grp (decm c d) (encm c d) (zkp c d) = true) ->
   ECount grp bs (edecrypt decm)
 | ecfin dm (w : cand -> bool) 
        (d : (forall c, (wins_type dm c) + (loses_type dm c))) :
        ECount grp bs (edecrypt dm) ->
        (forall c, w c = true <-> (exists x, d c = inl x)) ->
        (forall c, w c = false <-> (exists x, d c = inr x)) ->
        ECount grp bs (ewinners w). 
\end{verbatim}





We formally states that for every list of ballots, we can find a boolean 
function that decides winners \cite{Pattinson:2017:SVE}, but what more
important is that the term of type \textbf{ECount grp bs (ewinners f)}, 
that witnesses the correct execution of count, can be produced as evidence, 
known as certificate, to scrutineers to audit the election. 



\begin{verbatim}
  Lemma pschulze_winners (grp : Group) (bs : list eballot) :
     existsT (f : cand -> bool), ECount grp bs (ewinners f).
\end{verbatim}



Not only we provide the tally sheet (discussed in details in next section) 
to verify the computation, but we provide 
proof of correctness against fully verified implementation of 
Schulze method \cite{Pattinson:2017:SVE}. 
The basic intuition behind the proofs is very simple. 

(* This one is bit difficult to find *)
It basically hinges on the fact that 
if a ballot (represented as function $C \rightarrow N$)  
contributes to margin function then its 
encryption would also contribute to homomorphic margin, and vice-versa. 
  

\begin{verbatim}
  Lemma final_correctness :
    forall  (grp : Group) (bs : list ballot) (pbs : list pballot) 
    (ebs : list eballot) (w : cand -> bool)
    (H : pbs = map (fun x => 
         (fun c d => decrypt_message grp privatekey (x c d))) ebs)
    (H2 : mapping_ballot_pballot bs pbs), 
    Count bs (winners w) -> ECount grp ebs (ewinners w).
      
  Lemma final_correctness_rev :
    forall  (grp : Group) (bs : list ballot) (pbs : list pballot) 
    (ebs : list eballot) (w : cand -> bool)
    (H : pbs = map (fun x => 
         (fun c d => decrypt_message grp privatekey (x c d))) ebs)
    (H2 : mapping_ballot_pballot bs pbs),
    ECount grp ebs (ewinners w) -> Count bs (winners w).
\end{verbatim}



\section{Extraction and Experiments}
\texttt{ \begin{itemize}
  \item extension of Unicrypt with homomorphic addition
  \item coupling between library and extracted code
  \item need for light weight wrappers
  \item experimental results: how long, how much memory, certicicate
  size
\end{itemize}}


We use Coq extraction mechanism\cite{Letouzey:2003:NEC}  to extract its proofs into programs retaining all the terms which lives in Type universe, 
and erases every term  from Prop universe. 
We use this mechanism to extract our formalized Coq proofs into
 OCaml\cite{Leroy:2013:ORM} program, and instantiate the axiomatic cryptographic 
 primitives with corresponding primitives in Unicrypt library (* reference 
 for unicrypt ? *). For cryptographic purpose, we had choice to use 
 Unicrypt, and Verificatum, because both libraries
 are open source and exhaustively tested; however, we found Verificatum is 
 difficult to use, so we settled with Unicrypt. Since Unicrypt is written 
 in Java and our extracted code is in OCaml, we can not call Unicrypt functions 
 directly from OCaml. Besides, it does not have 
 all the primitives, homomorphic addition, construction of honest 
 decryption zero knowledge proof and its verification, 
 we need, so we have written wrapper, using Java-Ocaml library 
 (* github link for library? Robert Constable Has given links 
 of github in his paper about bar induction, the good, the bad and the 
 ugly *), with functionality missing 
 in Unicrypt, and it works as middle man between OCaml  and Java.
 

 
 After instantiating the  
 cryptographic primitives in extracted OCaml code 
 to Unicrypt library via wrapper, we ran it on set of
 small set of ballots with 3 candidate A, B, and C participating in election
 which produces the scrutiny sheet given below. In other words, 
 it is trace of computation which can be used as a checkable record to verify
 the outcome of election.
 
 
 
 
 
 
  
 



\begin{verbatim}
M: AA(13.., 10..) AB(90.., 14..) AC(11.., 23..) BA(16.., 13..) BB(79.., 46..)
BC(12.., 14..) CA(50.., 53..) CB(70.., 68..) CC(23.., 82..), 
D: [AA: 0 AB: 0 AC: 0 BA: 0 BB: 0 BC: 0 CA: 0 CB: 0 CC: 0], 
Zero-Knowledge-Proof-of-Honest-Decryption: [..]
---------------------------------------------------------------------------
V: [AA(42.., 15..) AB(63.., 32..) AC(70, 44..) BA(47.., 34..) BB(16.., 28..)
BC(39.., 16..) CA(19.., 13..) CB(57.., 12..) CC(19.., 89..),..], I:  [], 
M: AA(12.., 11..) AB(13.., 66..) AC(16.., 14.) BA(48.., 31..) BB(15.., 52..)
BC(15.., 68..) CA(39.., 69..) CB(12.., 78..) CC(10.., 40..),
Row-Permuted-Ballot: AA(53.., 16..) AB(23.., 44..) AC(72.., 47..)
BA(10.., 19..) BB(74.., 16..) BC(20.., 60..) CA(44.., 10..) CB(12.., 16..)
CC(59.., 98..),
Column-Permuted-Ballot: AA(81.., 41..) AB(17.., 14..) AC(10.., 14..) 
BA(37.., 12..) BB(14.., 66..) BC(10.., 13..) CA(12.., 13..) 
CB(14.., 16..) CC(12.., 10..),
Decryption-of-Permuted Ballot: AA0 AB-1 AC1 BA1 BB0 BC1 CA-1 CB-1 CC0,
Zero-Knowledge-Proof-of-Row-Permutation: [Tuple[...]], 
Zero-Knowledge-Proof-of-Column-Permutation: [Tuple[..]], 
Zero-Knowledge-Proof-of-Decryption: [Triple[..]], 
Permutation-Commitment: Triple[..]
Zero-Knowledge-Proof-of-Commitment: Tuple[..]
------------------------------------------------------------------------------------------
.
.
.
------------------------------------------------------------------------------------------
V: [AA(36.., 10..) AB(20.., 13..) AC(75.., 43..) BA(13.., 31..) BB(27.., 82..)
BC(31.., 50..) CA(16.., 11..) CB(74.., 15..) CC(26.., 36..)], I: [], M: AA(86.., 38..)
AB(21.., 14..) AC(16.., 25..) BA(16.., 22..) BB(18.., 15..) BC(11.., 63..)
CA(15.., 34..) CB(76.., 18..) CC(11.., 10..), 
Row-Permuted-Ballot: .., Column-Permuted-Ballot: .., 
Decryption-of-Permuted-Ballot: AA0 AB-10 AC1 BA10 BB0 BC1 CA-1 CB-1 CC0,
Zero-Knowledge-Proof-of-Row-Permutation: [..],
Zero-Knowledge-Proof-of-Column-Permutation: [..], 
Zero-Knowledge-Proof-of-Decryption: [..], 
Permutation-Commitment: Triple[..], 
Zero-Knowledge-Proof-of-Commitment: Tuple[..]
------------------------------------------------------------------------------------
V: [], I: [AA(36.., 10..) AB(20.., 13..) AC(75.., 43..) BA(13.., 31..) BB(27.., 82..)
BC(31.., 50..) CA(16.., 11..) CB(74.., 15..) CC(26.., 36..)], M: .., 
D: [AA: 0 AB: 4 AC: 4 BA: -4 BB: 0 BC: 4 CA: -4 CB: -4 CC: 0],
Zero-Knowledge-Proof-of-Decryption: [..]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D: [AA: 0 AB: 4 AC: 4 BA: -4 BB: 0 BC: 4 CA: -4 CB: -4 CC: 0]
winning: A
   for B: path A --> B of strength 4, 5-coclosed set: [(B,A),(C,A),(C,B)]
   for C: path A --> C of strength 4, 5-coclosed set: [(B,A),(C,A),(C,B)] 
losing: B
   exists A: path A --> B of strength 4, 4-coclosed set: [(A,A),(B,A),(B,B),(C,A),
   (C,B),(C,C)]
losing: C
   exists A: path A --> C of strength 4, 4-coclosed set: [(A,A),(B,A),(B,B),
   (C,A),(C,B),(C,C)]

\end{verbatim}


Now, we will wear the hat of scrutinizer to audit the election based on 
 scrutiny sheet to gain more understanding. In the very first line, all we 
 have to make sure that every entry is encrypted margin function M is encryption 
 of zero. As we can see that every entry in decrypted margin D 
 of encrypted margin M is zero, but we can verify this fact with 
 given Zero-Knowledge-Proof-of-Honest-Decryption.
 
 In next few lines, we need to make sure that if ballot from the top of 
 pile (all cast ballots) V is valid then it is added homomorphically to 
 running margin M, 
 and if not then moved to pile of invalid ballots I. In 
 order to certify the claim that ballot under consideration is valid, 
 or not, all we have to do is certify the claim that Row-Permuted-Ballot 
 is indeed row shuffle of ballot under consideration by 
 some (secret)permutation using the information  
 Zero-Knowledge-Proof-of-Row-Permutation, Permutation-Commitment, and 
 Zero-Knowledge-Proof-of-Commitment. We need to follow the same methodology 
 to verify the column permuted ballot Column-Permuted-Ballot. Finally, 
 all we have to verify the decryption claim of Decryption-of-Permuted-Ballot
 is honest decryption of Column-Permuted-Ballot using 
 Zero-Knowledge-Proof-of-Decryption. We keep doing this step until we have 
 processed all the ballots from pile V, i.e. V = []. 
 
 Once we have exhausted all the ballots from pile V, i.e. V = [], we 
 need to certify the that decrypted margin function D is indeed the 
 honest decryption of encrypted margin function M, and we can 
 verify this claim using Zero-Knowledge-Proof-of-Decryption.
 
 In final step, we need to check the claim of winner(s) and losers. 
 For winner(s), we need to verify that the claimed path exists with 
 the given strength, and claimed set is indeed the coclosed, and similar
 steps for losers.

In a nutshell, one can 
think of auditing the election involves verifying these three steps
\begin{itemize}
 \item The correctness of steps computing homomorphic margin 
 \item The decryption of fully constructed margin
 \item For winners 
\end{itemize} 

Even though, we produce the tally by formally verified code, election 
auditor has no information about how it was produced. This adds extra layer
of confidence in election, because the tally can be audited by pool
of scrutineers to certify the outcome of election.

The graph has been produced for three candidates for randomly generated ballots
on   an  Intel  i7  2.6  GHz  Linux  desktop  computer
with  8GB  of  ram.


\section{Analysis}

\noindent\emph{Summary.} The main contribution of our formalisation is that of independently
verifiable \emph{evidence} for a set of candidates to be the winners
of an election counted according to the Schulze method. Our main
claim is that that our notion of evidence is both safeguarding the
privacy of the individual ballot (as the count is based on encrypted
ballots) and is verifiable at the same time (by means of zero
knowledge proofs). To do this, we have axiomatised a set of
cryptographic primitives to deal with encryption, decryption,
correctness of shuffles and correctness of decryption. From formal
and constructive proof of the fact that such evidence can always be
obtained, we have then extracted executable code that is provably
correct by construction and produces election winners together with
evidence once implementations for the cryptographic primitives are
supplied.

In a second step, we have supplied an implementation of these
primitives, largely based on the Unicrypt Library. Our expertiments
have demonstrated that this approach is feasible, but quite clearly
much work is still needed to improve efficiency. 

\smallskip\noindent\emph{Assumptions for Provable Correctness.}
While we claim that the end product embodies a high level of
reliability, our approach necessarily leaves some gaps between the
executable and the formal proofs. First and foremost, this is of
course the implementation of the cryptographic primitives in an
external (and unverified) library. We have minimised this gap by
basing our implementation on a purpose-specific existing library
(Unicrypt) to which we relegate most of the functionality. Another
gap is the extraction mechanism of the Coq theorem prover which does
not come with formal correctness guarantees that reach down to the
machine code level such as for example CakeML~\cite{Kumar:2014:CVI}.

\smallskip\noindent\emph{Modelling Assumptions.} In our modelling of
the cryptographic primitives, in particular the zero knowledge
proofs, we have assumed that zero knowledge proofs can be verified,
whereas in reality zero-knowledge proofs just confirm facts with
very high probability which we have deliberately  ignored. As a
consequence our correctness assertions only hold to the level
of probability that is guaranteed by zero knowledge proofs.

\smallskip\noindent\emph{Scalability.} We have analysed the
feasibility of the extracted code by counting an increasing number
of ballots. While this demonstrates a proof of concept, our results
show that the cryptographic layer adds significant overhead compared
to plaintext tallying \cite{Pattinson:2017:SVE}.  Our present
hypothesis is that this overhead is created by the various layers of
bindings between the executable (extracted into OCaml) and the
Unicrypt library (implemented in Java) as each appears to be very
efficient individually. 

\smallskip\noindent\emph{Future Work.} Our axiomatisation of the
needed cryptographic primitives lays the foundation of creating a
verified library. For scalability, a more detailed analysis (and
profiling) of the software artefact are necessary. Orthogonal to
what we have presented here, it would also be of interest to develop
a provably correct verifier for the notion of certificate presented
here. 

\bibliographystyle{plain}
\bibliography{all2,delta2}

\appendix
\section*{Notes and Leftovers Start Here}



\section{Format of Ballots}

%\begin{itemize}
%  \item motivate the choice of ballots and compare with plaintext
%  version
%  \item define encryption function that changes representation
%  \item a ballot is valid if and only if there is evidence that
%  proves its validity
%  \item encrypting valid ballots leads to valid ballots, and the
%  same for invalid ballots 
%  \item 
  Each ballot, B, is a $n\times$n matrix where n is the number of candidates 
  participating in
  election. Each voter marks the entry (i,j) in ballot B as 1 if he prefers 
  candidate i over j
  otherwise mark it 0. No candidate is preferred over itself, so all the 
  diagonal entries are 
  filled with 0. 
  The reason for representing a ballot as a matrix because the precise 
\begin{itemize}
  \item motivate the choice of ballots and compare with plaintext
  version
  \item define encryption function that changes representation
  \item a ballot is valid if and only if there is evidence that
  proves its validity
  \item encrypting valid ballots leads to valid ballots, and the
  same for invalid ballots 
  
  \item Each ballot, B, is a $n\times$n matrix where n is the number of 
  candidates participating in election. Each voter marks the entry (i, j) as 1 
  and (j, i) as -1 in ballot B if  he prefers candidate $i$ over $j$. If the voter 
  has no preference between candidate $i$ and $j $ i.e. they are ranked 
  same then voter would mark entry (i, j) and (j, i) as 0. No candidate is 
  preferred over itself, so all the diagonal entries are  filled with 0.  The
   reason for representing a ballot as a matrix because the precise 

  nature of our algorithm involving no decryption of individual ballot to protect
  ballot privacy,  facilitating the scrutiny for validity, and ease of computing 
  cumulative margin over encrypted data to compute the winners. 
  
  
   

  Each entry in ballot is encrypted by additive ElGamal i.e. encrypting the 
  message m as ($g^{r}, h^{r}g^{m}$) where $g$ is generator of cycle group $G$, and 
  $h = g^{x}$ is private key. After performing the encryption, a plain text ballot 
  i.e. matrix having entries of 0, and 1 changes to a matrix having pair for 

  \item  Each entry in ballot is encrypted by additive ElGamal i.e. encrypting the 
  message m as ($g^{r}, h^{r}g^{m}$) where $g$ is generator of cycle group $G$ of order $q$,  private key $x$ and randomness $r$  are randomly  
  chosen from \{1, \ldots, $q$ - 1\}, and public key is computed as 
  $h = g^{x}$. It is important to note that generator $g$, private key $x$ and 
  public key $h$ are generated during key generation phase of Elgamal 
  algorithm while  randomness $r$  is generated fresh for each message.
 \end{itemize} 
  After performing the encryption, a plain text ballot 
  i.e. matrix having entries of -1,  0, and 1 changes to a matrix having pair for 
  each entry representing the encryption of corresponding plain text. 
  A representation of plain text ballot  
  \[  
  \begin{bmatrix}
    x_{11}       & x_{12} & x_{13} & \dots & x_{1n} \\
    x_{21}       & x_{22} & x_{23} & \dots & x_{2n} \\
    \hdotsfor{5} \\
    x_{n1}       & x_{n2} & x_{n3} & \dots & x_{nn}
  \end{bmatrix}\] and data structure used to represent this ballot in 
  Coq is
  \begin{verbatim}
   Definition plaintext := Z.
   Definition pballot := cand -> cand -> plaintext.
  \end{verbatim}
  A representation of encrypted ballot 
  \[  
  \begin{bmatrix}
    (y_{11}, z_{11}) & (y_{12}, z_{12}) & (y_{13}, z_{13}) & \dots & (y_{1n}, z_{1n}) \\
    (y_{21}, z_{21}) & (y_{22}, z_{22}) & (y_{23}, z_{23}) & \dots & (y_{2n}, z_{2n}) \\
    \hdotsfor{5} \\
    (y_{n1}, z_{n1}) & (y_{n2}, z_{n2}) & (y_{n3}, z_{n3}) & \dots & (y_{nn}, z_{nn})
  \end{bmatrix}\] and the corresponding data structure in Coq is 
  \begin{verbatim}
   Definition ciphertext := (Z * Z)%type.
   Definition eballot := cand -> cand -> ciphertext.
  \end{verbatim}
     
 The reason for using additive ElGamal is that it's composability on ciphertext 
 under same public key. In short,  (Should I explain the algorithm here that 
  why this scheme works or explain it encryption section ?)
 \begin{center}  
	$enc_{k}(m_{1}) * enc_{k}(m_{2}) = enc_{k} (m_{1} + m_{2})$
 \end{center}
 Our choice of representing ballot as matrix comes with price. A malicious 
 voter could try to encode all sort of ballots including cyclic ones i.e. candidate
 $A$ is preferred over candidate $B$, candidate $B$ is preferred over candidate $C$, 
 and candidate $C$ is preferred over candidate $A$, and it is clear that voter has
 not expressed his choices clearly as it can not be expressed in linear preference order 
 and should not be considered for counting, or 
 he could inflate his favourite candidate by any other number higher that 1, and It 
 makes the ballot invalid because any value greater that 1 in a ballot would be similar
 to voter has casted more than one vote. We define a ballot is valid if all the 
 entries in matrix is encryption of -1, 0 and 1, and there is no cycle in it. Formally, We have
 \begin{verbatim}
 
	Definition matrix_ballot_valid (p : pballot) :=
      (forall c d : cand, In (p c d) [-1; 0; 1]) /\
	       valid cand p.  
 
 
 Definition valid (A : Type) (P : A -> A -> Z) :=
      exists f : A -> nat,
          forall c d : A,
          (P c d = 1 <-> (f c < f d)%nat) /\
          (P c d = 0 <-> f c = f d) /\ 
          (P c d = -1 <-> (f c > f d)%nat)
          
     (* Which one should keep ? Upper one is in Code while this one is 
        more intutive after expanding the definition *) 
    Definition matrix_ballot_valid (p : pballot) :=
      (forall c d : cand, In (p c d) [-1; 0; 1]) /\
      (exists f : A -> nat,
          forall c d : A,
          (p c d = 1 <-> (f c < f d)%nat) /\
          (p c d = 0 <-> f c = f d) /\ 
          (p c d = -1 <-> (f c > f d)%nat))
    
 \end{verbatim}
 Intuitively, it says that a ballot p is valid if we can find a function which
  expresses 
 the notion of linear preference ordering for all candidates, and 
 we prove that we can decide for each ballot if it is valid or not 
 \begin{verbatim}
  Lemma matrix_ballot_valid_dec : 
        forall p : pballot, {matrix_ballot_valid p} +
                            {~matrix_ballot_valid p}.
 \end{verbatim}
 
 By now, a attentive reader would note that we have claimed that we don't decrypt
 the ballot to preserve the privacy, so how can we decide the validity 
 without decrypting the original ballot. We will discuss our whole cryptographic 
 scheme in next section, but to quench the thrust of reader for now, we have 
 proved that if ballot p was valid
 before encryption, then encrypting it followed by permuting each row by 
 secret permutation $\sigma$ and permuting again the each column of resulting matrix 
 from  previous step by same permutation, $\sigma$, and decrypting it back would
 still 
 lead to valid ballot. 
 (* Write this same Lemma for $matrix_ballot_valid$ then 
      any permutation of it is valid and if it is invalid then any permutation of 
       it is invalid. The proof is already lying there in other proofs so 
       it's basically copy paste.   *)
 \begin{verbatim}
 Lemma perm_presv_validity :
     forall (A : Type) (P : A -> A -> Z),
       (forall c d : A, {c = d} + {c <> d}) ->
       (forall c d : A, {P c d = 1} + {P c d = 0} + {P c d = -1}) ->
       forall sig : A -> A, Bijective sig -> valid A P <-> valid A (perm A P sig)
 \end{verbatim}
 And similarly, for invalid ballot 
 \begin{verbatim}
 Lemma not_perm_persv_validity :
  forall (A : Type) (P : A -> A -> Z),
       (forall c d : A, {c = d} + {c <> d}) ->
       (forall c d : A, {P c d = 1} + {P c d = 0} + {P c d = -1}) ->
       forall sig : A -> A, Bijective sig -> ~ valid A P <-> ~ valid A (perm A P sig).
\end{verbatim}
%\end{itemize}

\section{Homomorphic Computation of Margin}
\begin{itemize}
  \item motivate and introduce how the margin is computed
  homomorphcially
  \item prove that encrption commutes with computation of margin
  
\end{itemize}

\section{Homomorphic Counting}
\begin{itemize}
  \item prove that encruption commutes with computation of winners
  \item discuss the evidence: publish cleartext margin function
  \item describe certificates and how to check them
\end{itemize}

\section{Experimental Results}
\begin{itemize}
  \item how long does it take, and how much memory?
  \item how large are the certificates?
\end{itemize}


\section{Discussion and Further Work}



One aspect that we have not considered here is encryption of
ballots to safe-guard voter privacy which can be incorporated using
protocols such as shuffle-sum \cite{Benaloh:2009:SSC} and
homomorphic encryption \cite{Yi:2014:HEA}. The key idea here is to
formalise a given voting scheme based on encrypted ballots, and then
to establish a homomorphic property: the decryption of the result
obtained from encrypted ballots is the same as the result obtained from
the decrypted ballots.  We leave this to further work.

%\bibliographystyle{myplain}
%\bibliography{all2,delta2}


\end{document}
